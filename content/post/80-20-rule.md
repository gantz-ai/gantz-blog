+++
title = "The 80/20 Rule for AI Agents"
date = 2026-01-05
image = "images/developer-coding.png"
draft = false
tags = ['best-practices', 'architecture', 'patterns']
+++


80% of your agent's value comes from 20% of its features.

The other 80% of features? They cause 80% of your bugs.

## The Pareto principle, applied

In AI agents:

- **20% of tools** handle **80% of tasks**
- **20% of code** creates **80% of value**
- **20% of edge cases** cause **80% of failures**
- **20% of prompt** does **80% of work**

Most developers build the 80% that doesn't matter. Then wonder why their agent is fragile.

## Tools: Less is more

### The tool explosion

```yaml
# What developers build
tools:
  - read_file
  - read_file_lines
  - read_file_range
  - read_file_head
  - read_file_tail
  - read_json_file
  - read_yaml_file
  - read_csv_file
  - read_binary_file
  - read_file_metadata
  # ... 40 more tools
```

### The reality

```yaml
# What actually gets used
tools:
  - read_file      # 70% of all tool calls
  - search         # 20% of all tool calls
  - write_file     # 8% of all tool calls
  - everything_else # 2%
```

### The 80/20 approach

```yaml
# Build these well
tools:
  - name: read
    description: Read any file. Handles text, JSON, YAML automatically.

  - name: search
    description: Search files by content or name.

  - name: write
    description: Write or update files.

  - name: run
    description: Run shell commands.

# That's it. 4 tools. Covers 95% of use cases.
```

## Prompts: Trim the fat

### The bloated prompt

```python
# 2,500 tokens
SYSTEM_PROMPT = """
You are an advanced AI assistant designed to help users with a wide
variety of tasks. Your primary goal is to be helpful, harmless, and
honest in all interactions. When responding to user queries, you
should carefully consider the context and provide thoughtful,
well-reasoned responses.

You have access to a suite of powerful tools that allow you to
interact with external systems, retrieve information, and perform
various operations. When using these tools, always follow best
practices and consider the implications of your actions.

Here are some guidelines for your behavior:
1. Always be polite and professional
2. If you're unsure about something, ask for clarification
3. Think step by step before taking action
4. Consider multiple approaches before choosing one
5. Verify your work when possible
6. Be concise but thorough in your explanations
7. Use markdown formatting when appropriate
8. Cite sources when providing factual information
9. Respect user privacy and confidentiality
10. Acknowledge limitations honestly

When handling code:
- Always read files before modifying them
- Make minimal, targeted changes
- Test changes when possible
- Follow existing code style
- Add comments for complex logic
- Consider error handling
- Think about edge cases
...
[500 more words]
"""
```

### The 80/20 prompt

```python
# 200 tokens
SYSTEM_PROMPT = """
You're a coding assistant with file and shell access.

Rules:
- Read before editing
- Minimal changes
- Ask if unclear

Be concise.
"""
```

Same behavior. 90% fewer tokens.

## Features: Do less, better

### The feature creep

```python
# What developers plan
class Agent:
    def __init__(self):
        self.memory = VectorMemory()
        self.planner = HierarchicalPlanner()
        self.reflector = SelfReflectionModule()
        self.evaluator = QualityEvaluator()
        self.personas = PersonaManager()
        self.emotions = EmotionalStateTracker()
        self.learning = OnlineLearningModule()
        self.collaboration = MultiAgentCoordinator()
        self.explanation = ExplainabilityEngine()
        self.safety = SafetyChecker()
        # ... 20 more modules
```

### What actually matters

```python
# What delivers value
class Agent:
    def __init__(self):
        self.tools = ToolExecutor()      # Call tools
        self.context = ContextManager()  # Manage history
        self.llm = LLMClient()           # Talk to model

    def run(self, task):
        while not done:
            action = self.llm.decide(self.context.get())
            if action.is_tool_call:
                result = self.tools.execute(action)
                self.context.add(result)
            else:
                return action.response
```

Three components. Handles 80% of use cases.

## Error handling: Focus on common failures

### Over-engineering

```python
# Handling every possible error
try:
    result = tool.execute(params)
except NetworkTimeoutError:
    # Retry with exponential backoff
except RateLimitError:
    # Wait and retry
except AuthenticationError:
    # Refresh token and retry
except InvalidParameterError:
    # Ask LLM to fix params
except ToolNotFoundError:
    # Suggest alternative tools
except PartialResultError:
    # Handle partial data
except CircuitBreakerOpenError:
    # Use fallback tool
except CacheExpiredError:
    # Refresh cache
except QuotaExceededError:
    # Notify user about quota
except MaintenanceModeError:
    # Wait for maintenance to end
# ... 20 more error types
```

### The 80/20 approach

```python
# Handle the 3 errors that actually happen
try:
    result = tool.execute(params)
except TimeoutError:
    result = {"error": "Tool timed out. Try again or use different approach."}
except Exception as e:
    result = {"error": f"Tool failed: {str(e)}"}

# That's it. Add more error types when they actually occur in production.
```

## Context management: Simple wins

### Over-engineering

```python
class ContextManager:
    def __init__(self):
        self.short_term = ShortTermMemory()
        self.long_term = LongTermMemory()
        self.episodic = EpisodicMemory()
        self.semantic = SemanticMemory()
        self.procedural = ProceduralMemory()
        self.working = WorkingMemory()
        self.retrieval = HybridRetriever()
        self.compression = AdaptiveCompressor()
        self.importance = ImportanceScorer()
        self.decay = MemoryDecayManager()
```

### The 80/20 approach

```python
class ContextManager:
    def __init__(self, max_messages=30):
        self.messages = []
        self.max_messages = max_messages

    def add(self, message):
        self.messages.append(message)
        if len(self.messages) > self.max_messages:
            self.messages = self.messages[-self.max_messages:]

    def get(self):
        return self.messages
```

Sliding window. Works for 80% of cases.

## The build order

Most developers:
1. Build complex memory system
2. Build multi-agent coordination
3. Build reflection/evaluation
4. Build the basic tool calling
5. Ship

80/20 developers:
1. Build basic tool calling
2. Ship
3. Add what's actually needed
4. Ship again

## Identify your 20%

### For a coding assistant

The vital 20%:
- Read files
- Write files
- Run commands
- Search code

Not vital (yet):
- Automatic refactoring
- Code generation from specs
- Multi-file orchestration
- Test generation

### For a customer support agent

The vital 20%:
- Search knowledge base
- Look up customer info
- Create tickets

Not vital (yet):
- Sentiment analysis
- Automatic escalation
- Multi-language support
- Voice integration

### For a data analyst

The vital 20%:
- Query database
- Format results
- Basic charts

Not vital (yet):
- ML predictions
- Automatic insights
- Report generation
- Anomaly detection

## How to find your 20%

### Step 1: Log everything

```python
class UsageTracker:
    def __init__(self):
        self.tool_usage = Counter()
        self.feature_usage = Counter()

    def track_tool(self, tool_name):
        self.tool_usage[tool_name] += 1

    def report(self):
        total = sum(self.tool_usage.values())
        for tool, count in self.tool_usage.most_common():
            print(f"{tool}: {count} ({count/total*100:.1f}%)")
```

### Step 2: Analyze

```
Tool usage (last 30 days):
  read_file:    4,521 (45.2%)
  search:       2,847 (28.5%)
  write_file:   1,623 (16.2%)
  run_command:    847 (8.5%)
  other:          162 (1.6%)   ← All 15 other tools combined
```

### Step 3: Double down on the 20%

Make `read_file`, `search`, `write_file`, and `run_command` bulletproof.

Delete or simplify the rest.

## The 80/20 development process

### Week 1: Core loop

```python
# Just this
while True:
    user_input = get_input()
    response = llm.respond(user_input)
    print(response)
```

### Week 2: Add tools

```python
# Add 3-5 essential tools
tools = [read_file, search, write_file]
```

### Week 3: Deploy

```bash
# Ship it
gantz --config basic-tools.yaml
```

### Week 4+: Iterate based on real usage

```
"Users are asking for X" → Add tool for X
"Tool Y keeps failing" → Fix tool Y
"Nobody uses tool Z" → Remove tool Z
```

## Building with Gantz

Start minimal with [Gantz](https://gantz.run):

```yaml
# gantz.yaml - The 80/20 toolkit
tools:
  - name: read
    description: Read a file
    parameters:
      - name: path
        type: string
        required: true
    script:
      shell: cat "{{path}}"

  - name: search
    description: Search files for content
    parameters:
      - name: query
        type: string
        required: true
    script:
      shell: rg "{{query}}" . --max-count=20

  - name: write
    description: Write to a file
    parameters:
      - name: path
        type: string
        required: true
      - name: content
        type: string
        required: true
    script:
      shell: echo "{{content}}" > "{{path}}"

  - name: run
    description: Run a shell command
    parameters:
      - name: command
        type: string
        required: true
    script:
      shell: "{{command}}"
```

Four tools. Covers most use cases. Add more only when needed.

## Red flags you're building the 80%

- "We might need this later"
- "Best practice says we should have..."
- "What if the user wants to..."
- "It would be cool to add..."
- "Other agents have this feature"
- "It's only a few more lines of code"

## Signs you're on the 20%

- "Users are actually asking for this"
- "This tool is called 100x/day"
- "This is blocking real use cases"
- "The simplest solution that works"
- "We can add complexity later"

## Summary

The 80/20 rule for agents:

| Area | The 20% that matters | The 80% that doesn't |
|------|---------------------|---------------------|
| Tools | 3-5 core tools | 20 specialized tools |
| Prompt | Clear, concise rules | Pages of guidelines |
| Features | Tool calling + context | Memory, planning, reflection |
| Errors | Common failures | Every edge case |
| Context | Sliding window | Multi-tier memory |

Build the 20%. Ship. Learn what else is actually needed.

Don't build the 80% because you think you might need it.

---

*What's in your agent's vital 20%?*
